\section{SyGuS-Sketcher: A preliminary prototype}

Instead of solving the larger problem as mentioned in the previous section, we decided to solve a sub-problem first.
We have begun implementing a preliminary prototype as a tool which we call SyGuS-Sketcher. SyGuS-Sketcher is built atop DeepSynth \cite{polgreen2020counterexample} and is available on github.\footnote{\url{https://github.com/stanlysamuel/sygus-sketcher}}. In this section, we discuss the tool architecture for SyGuS-Sketcher  and experimentation direction. The aim of this prototype is to show that sketches for logical specifications can indeed help improve the performance and number of benchmarks solved as compared to DeepSynth. This is our hypothesis.

\subsection{Tool architecture}

Figure~\ref{fig:curr} shows the prototype architecture. As you can see, the architecture is similar to DeepSynth except for two modifications. First, out of the top K candidates selected by the DeepSynth's NN, we select the candidate most likely to be correct, which is a complete program. Next, we replace the constant values with constant literals to generate a sketch. This is as good as assuming that we do not trust the constants generated by the Neural Network but use existing sketch compilers to fill up the program while guaranteeing the correctness of the specification. Thus, this boils down to a problem of solving sketches with constant holes which is exactly what the Sketch tool\cite{10.5555/1714168} does. However, for the bit-vector invariant generation benchmarks that we use, Sketch has limited support. For example, bit-vector subtraction and relational operators are not supported in Sketch due to which we had to look for other options. Thus, we looked into CEGIS(T) verifier which has this support. They have a Fourier Motzkin and an SMT based verifier and we need to decide which one fits in our case. We are currently in the process of implementing this integration. This is the second modification from DeepSynth.

%\Stanly{Try explaining the sketches with an example}


% ---------------------- CODE FOR OUR CURRENT IMPLEMENTATION --------------------------
\begin{figure*}
\resizebox{!}{!}{%
\begin{tikzpicture}[node distance=2cm]
\node (pr) [process] {LOGICAL SPEC};
\node (sam) [startstop, right of=pr, xshift=1.5cm] {SAMPLER};
\node (nn) [startstop, right of=sam, xshift=2cm] {NN (DEEPSYNTH)};
\node (sol) [startstop, right of=nn, xshift=3.5cm] {CEGIS(T)};
\node (bs) [process, below of=nn, yshift=-0.5cm] {NO SOLUTION};
\node (dec1) [decision, below of=sol, yshift=-0.5cm] {SOLVED?};
\node (sn) [solution, below of=dec1, yshift=-0.5cm] {PROGRAM};
\draw [arrow] (pr) -- node[anchor=south] {} (sam);
\draw [arrow] (sam) -- node[anchor=south] {I/O} (nn);
\draw [arrow] (sam) -- node[anchor=north] {Examples} (nn);
\draw [arrow] (nn) -- node[anchor=south] {SKETCHES with} (sol);
\draw [arrow] (nn) -- node[anchor=north] {Constant HOLE} (sol);
\draw [arrow] (sol) -- node[anchor=south] {} (dec1);
\draw [arrow] (dec1) -- node[anchor=south] {NO} (bs);
\draw [arrow] (dec1) -- node[anchor=west] {YES} (sn);
\end{tikzpicture}
}
\caption{SyGuS-Sketcher architecture}
\label{fig:curr}
\end{figure*}

\subsection{Planned experiment}

We plan to test this prototype against DeepSynth's 88 bit-vector invariant benchmarks. We describe a subset of these benchmark timings below: \\

\begin{tabular}{ |p{2cm}||p{2cm}|p{2cm}|  }

 \hline
 Benchmarks & DeepSynth  & SyGuS-Sketcher\\
 \hline
 anfp-new   &  23.7529s & .   \\
 formula22    & 44.5536s & . \\
 hola.05 &   165.086s & .  \\
array-new & 76.1318s  & . \\
 cegar2-new&106.402s  & .\\
 \hline
\end{tabular} \\

As you can observe, DeepSynth takes a considerable amount of time whereas traditional solvers without neural network architectures have an order in milliseconds. This is where we expect Sketches to play a role in improving the performance time.


